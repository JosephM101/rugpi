//! Utilities for the Grub boot flow.

use std::{
    collections::HashMap,
    fs::{self, File},
    io::Write,
    path::Path,
};

use reportify::{Report, ResultExt};
use sha1::{Digest, Sha1};
use thiserror::Error;

use crate::{
    system::System,
    utils::ascii_numbers::{self, bytes_to_ascii_hex},
};

/// Signature of Grub environment blocks.
const ENVBLK_SIGNATURE: &str = "# GRUB Environment Block\n";

/// Size of Grub environment blocks.
const ENVBLK_SIZE: usize = 1024;

/// Decode a Grub environment block.
pub fn grub_envblk_decode(blk: &str) -> Result<HashMap<String, String>, InvalidEnvblk> {
    if blk.as_bytes().len() != ENVBLK_SIZE {
        return Err(InvalidEnvblk::InvalidLength);
    }
    let mut values = HashMap::new();
    for line in blk.split('\n') {
        if line.starts_with('#') {
            // Skip any lines starting with `#`, including the signature.
            continue;
        }
        if let Some((name, value)) = line.split_once('=') {
            let mut unescaped = String::with_capacity(value.len());
            let mut chars = value.chars();
            while let Some(c) = chars.next() {
                if c == '\\' {
                    match chars.next() {
                        Some('\\') => unescaped.push('\\'),
                        Some('\n') => unescaped.push('\n'),
                        _ => return Err(InvalidEnvblk::InvalidEscaped),
                    }
                } else {
                    unescaped.push(c)
                }
            }
            values.insert(name.to_owned(), unescaped);
        } else {
            return Err(InvalidEnvblk::InvalidEntry);
        }
    }
    Ok(values)
}

/// Invalid environment block.
#[derive(Debug, Clone, Error)]
pub enum InvalidEnvblk {
    /// Block has an invalid length.
    #[error("environment block has an invalid length")]
    InvalidLength,
    /// Block has an invalid signature.
    #[error("environment block has an invalid signature")]
    InvalidSignature,
    /// Block has an invalid entry.
    #[error("environment block has an invalid entry")]
    InvalidEntry,
    /// Block has an improperly escaped value.
    #[error("environment block contains an improperly escaped value")]
    InvalidEscaped,
}

pub const RUGPI_BOOTPART: &str = "rugpi_bootpart";
const RUGPI_BOOT_SPARE: &str = "rugpi_boot_spare";

/// Encode a Grub environment block.
pub fn grub_envblk_encode(values: &HashMap<String, String>) -> Result<String, InvalidEnvblk> {
    let mut encoded = String::with_capacity(ENVBLK_SIZE);
    encoded.push_str(ENVBLK_SIGNATURE);
    encoded.push_str("# WARNING: Do not edit this file by tools other than grub-editenv!!!\n");
    for (name, value) in values {
        assert!(!name.contains('\n'));
        encoded.push_str(name);
        encoded.push('=');
        for c in value.chars() {
            match c {
                '\\' => encoded.push_str("\\\\"),
                '\n' => encoded.push_str("\\n"),
                _ => encoded.push(c),
            }
        }
        encoded.push('\n');
    }
    if encoded.as_bytes().len() > ENVBLK_SIZE {
        return Err(InvalidEnvblk::InvalidLength);
    }
    while encoded.as_bytes().len() < ENVBLK_SIZE {
        encoded.push('#');
    }
    Ok(encoded)
}

reportify::new_whatever_type! {
    GrubEnvError
}

pub fn write_with_hash(
    values: &HashMap<String, String>,
    path: &Path,
    abs_path: &str,
) -> Result<(), Report<GrubEnvError>> {
    let encoded = grub_envblk_encode(values).whatever("unable to encode Grub environment")?;
    let mut path_new = path.to_path_buf().into_os_string();
    path_new.push(".new");
    let mut bootpart_new = File::create(&path_new).whatever("unable to create new environment")?;
    bootpart_new
        .write_all(encoded.as_bytes())
        .whatever("unable to write new environment")?;
    bootpart_new
        .flush()
        .whatever("unable to flush new environment")?;
    bootpart_new
        .sync_all()
        .whatever("unable to sync new environment")?;
    let mut path_sha1 = path.to_path_buf().into_os_string();
    path_sha1.push(".sha1");
    let mut hash = Sha1::new();
    hash.update(encoded);
    let digest = bytes_to_ascii_hex(&hash.finalize(), ascii_numbers::Case::Lower);
    std::fs::write(&path_sha1, format!("{digest}  {abs_path}"))
        .whatever("unable to write digest file")?;
    std::fs::rename(path_new, path).whatever("unable to rename Grub environment")?;
    Ok(())
}

pub fn grub_write_defaults(config_path: &Path) -> Result<(), Report<GrubEnvError>> {
    let mut bootpart = HashMap::new();
    bootpart.insert(RUGPI_BOOTPART.to_owned(), "2".to_owned());
    write_with_hash(
        &bootpart,
        &config_path.join("rugpi/primary.grubenv"),
        "/rugpi/primary.grubenv",
    )?;
    write_with_hash(
        &bootpart,
        &config_path.join("rugpi/secondary.grubenv"),
        "/rugpi/secondary.grubenv",
    )?;
    let mut boot_spare = HashMap::new();
    boot_spare.insert(RUGPI_BOOT_SPARE.to_owned(), "false".to_owned());
    std::fs::write(
        config_path.join("rugpi/boot_spare.grubenv"),
        grub_envblk_encode(&boot_spare).whatever("unable to encode Grub environment")?,
    )
    .whatever("unable to write Grub environment")?;
    Ok(())
}

pub type GrubEnv = HashMap<String, String>;

pub fn load_grub_env<P: AsRef<Path>>(path: P) -> Result<GrubEnv, Report<GrubEnvError>> {
    fn inner(path: &Path) -> Result<GrubEnv, Report<GrubEnvError>> {
        Ok(grub_envblk_decode(
            &fs::read_to_string(path).whatever("unable to read Grub environment")?,
        )
        .whatever("unable to decode Grub environment")?)
    }
    inner(path.as_ref())
}

pub fn save_grub_env<P: AsRef<Path>>(path: P, env: &GrubEnv) -> Result<(), Report<GrubEnvError>> {
    fn inner(path: &Path, env: &GrubEnv) -> Result<(), Report<GrubEnvError>> {
        let mut tmp_path = path.to_path_buf();
        tmp_path.as_mut_os_string().push(".tmp");
        let mut tmp_file = fs::File::create(&tmp_path)
            .whatever("unable to create temporary Grub environment file")?;
        tmp_file
            .write_all(
                grub_envblk_encode(env)
                    .whatever("unable to encode Grub environment")?
                    .as_bytes(),
            )
            .whatever("unable to write to temporary Grub environment file")?;
        tmp_file
            .sync_all()
            .whatever("unable to sync temporary Grub environment file")?;
        fs::rename(&tmp_path, path).whatever("unable to replace Grub environment file")?;
        Ok(())
    }
    inner(path.as_ref(), env)
}

pub fn set_spare_flag(system: &System) -> Result<(), Report<GrubEnvError>> {
    let mut envblk = HashMap::new();
    envblk.insert(RUGPI_BOOT_SPARE.to_owned(), "true".to_owned());
    let envblk = grub_envblk_encode(&envblk).whatever("unable to encode Grub environment")?;
    let config_partition = system
        .require_config_partition()
        .whatever("unable to get config partition")?;
    config_partition
        .ensure_writable(|| -> Result<(), Report<GrubEnvError>> {
            // It is safe to directly write to the file here. If the file is corrupt,
            // the system will simply boot from the default partition set.
            std::fs::write(
                config_partition.path().join("rugpi/boot_spare.grubenv"),
                envblk,
            )
            .whatever("unable to write Grub environment")?;
            Ok(())
        })
        .whatever("unable to make config partition writable")??;
    Ok(())
}

pub fn clear_spare_flag(system: &System) -> Result<(), Report<GrubEnvError>> {
    let mut envblk = HashMap::new();
    envblk.insert(RUGPI_BOOT_SPARE.to_owned(), "false".to_owned());
    let envblk = grub_envblk_encode(&envblk).whatever("unable to encode Grub environment")?;
    let config_partition = system
        .require_config_partition()
        .whatever("unable to get config partition")?;
    config_partition
        .ensure_writable(|| -> Result<(), Report<GrubEnvError>> {
            // It is safe to directly write to the file here. If the file is corrupt,
            // the system will simply boot from the default partition set.
            std::fs::write(
                config_partition.path().join("rugpi/boot_spare.grubenv"),
                envblk,
            )
            .whatever("unable to write Grub environment")?;
            Ok(())
        })
        .whatever("unable to make config partition writable")??;
    Ok(())
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use crate::boot::grub::{grub_envblk_decode, grub_envblk_encode};

    #[test]
    pub fn test_empty() {
        const GRUBENV: &str = include_str!("../../assets/grub/grubenv");
        assert_eq!(GRUBENV, grub_envblk_encode(&HashMap::new()).unwrap());
    }

    #[test]
    pub fn test_roundtrip() {
        const GRUBENV: &str = include_str!("../../assets/grub/grubenv");
        assert_eq!(
            GRUBENV,
            grub_envblk_encode(&grub_envblk_decode(GRUBENV).unwrap()).unwrap()
        );
        const DEFAULT: &str = include_str!("../../assets/grub/default.env");
        assert_eq!(
            DEFAULT,
            grub_envblk_encode(&grub_envblk_decode(DEFAULT).unwrap()).unwrap()
        );
    }
}
