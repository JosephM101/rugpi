//! Utilities for the Grub boot flow.

use std::{collections::HashMap, fs::File, io::Write, path::Path};

use anyhow::bail;
use sha1::{Digest, Sha1};
use thiserror::Error;

use crate::{
    partitions::{make_config_writeable, PartitionSet},
    paths::config_partition_path,
    utils::ascii_numbers::{self, bytes_to_ascii_hex},
    Anyhow,
};

/// Signature of Grub environment blocks.
const ENVBLK_SIGNATURE: &str = "# GRUB Environment Block\n";

/// Size of Grub environment blocks.
const ENVBLK_SIZE: usize = 1024;

/// Decode a Grub environment block.
pub fn grub_envblk_decode(blk: &str) -> Result<HashMap<String, String>, InvalidEnvblk> {
    if blk.as_bytes().len() != ENVBLK_SIZE {
        return Err(InvalidEnvblk::InvalidLength);
    }
    let mut values = HashMap::new();
    for line in blk.split('\n') {
        if line.starts_with('#') {
            // Skip any lines starting with `#`, including the signature.
            continue;
        }
        if let Some((name, value)) = line.split_once('=') {
            let mut unescaped = String::with_capacity(value.len());
            let mut chars = value.chars();
            while let Some(c) = chars.next() {
                if c == '\\' {
                    match chars.next() {
                        Some('\\') => unescaped.push('\\'),
                        Some('\n') => unescaped.push('\n'),
                        _ => return Err(InvalidEnvblk::InvalidEscaped),
                    }
                } else {
                    unescaped.push(c)
                }
            }
            values.insert(name.to_owned(), unescaped);
        } else {
            return Err(InvalidEnvblk::InvalidEntry);
        }
    }
    Ok(values)
}

/// Invalid environment block.
#[derive(Debug, Clone, Error)]
pub enum InvalidEnvblk {
    /// Block has an invalid length.
    #[error("environment block has an invalid length")]
    InvalidLength,
    /// Block has an invalid signature.
    #[error("environment block has an invalid signature")]
    InvalidSignature,
    /// Block has an invalid entry.
    #[error("environment block has an invalid entry")]
    InvalidEntry,
    /// Block has an improperly escaped value.
    #[error("environment block contains an improperly escaped value")]
    InvalidEscaped,
}

const RUGPI_BOOTPART: &str = "rugpi_bootpart";
const RUGPI_BOOT_SPARE: &str = "rugpi_boot_spare";

/// Encode a Grub environment block.
pub fn grub_envblk_encode(values: &HashMap<String, String>) -> Result<String, InvalidEnvblk> {
    let mut encoded = String::with_capacity(ENVBLK_SIZE);
    encoded.push_str(ENVBLK_SIGNATURE);
    encoded.push_str("# WARNING: Do not edit this file by tools other than grub-editenv!!!\n");
    for (name, value) in values {
        assert!(!name.contains('\n'));
        encoded.push_str(name);
        encoded.push('=');
        for c in value.chars() {
            match c {
                '\\' => encoded.push_str("\\\\"),
                '\n' => encoded.push_str("\\n"),
                _ => encoded.push(c),
            }
        }
        encoded.push('\n');
    }
    if encoded.as_bytes().len() > ENVBLK_SIZE {
        return Err(InvalidEnvblk::InvalidLength);
    }
    while encoded.as_bytes().len() < ENVBLK_SIZE {
        encoded.push('#');
    }
    Ok(encoded)
}

pub fn read_default_partitions() -> Anyhow<PartitionSet> {
    let bootpart_env = grub_envblk_decode(&std::fs::read_to_string(&config_partition_path(
        "rugpi/primary.grubenv",
    ))?)?;
    let Some(bootpart) = bootpart_env.get(RUGPI_BOOTPART) else {
        bail!("Invalid bootpart environment.");
    };
    if bootpart == "2" {
        Ok(PartitionSet::A)
    } else if bootpart == "3" {
        Ok(PartitionSet::B)
    } else {
        bail!("Invalid default `bootpart`.");
    }
}

pub fn write_with_hash(
    values: &HashMap<String, String>,
    path: &Path,
    abs_path: &str,
) -> Anyhow<()> {
    let encoded = grub_envblk_encode(values)?;
    let mut path_new = path.to_path_buf().into_os_string();
    path_new.push(".new");
    let mut bootpart_new = File::create(&path_new)?;
    bootpart_new.write_all(encoded.as_bytes())?;
    bootpart_new.flush()?;
    bootpart_new.sync_all()?;
    let mut path_sha1 = path.to_path_buf().into_os_string();
    path_sha1.push(".sha1");
    let mut hash = Sha1::new();
    hash.update(encoded);
    let digest = bytes_to_ascii_hex(&hash.finalize(), ascii_numbers::Case::Lower);
    std::fs::write(&path_sha1, format!("{digest}  {abs_path}"))?;
    std::fs::rename(path_new, path)?;
    Ok(())
}

pub fn grub_write_defaults(config_path: &Path) -> Anyhow<()> {
    let mut bootpart = HashMap::new();
    bootpart.insert(RUGPI_BOOTPART.to_owned(), "2".to_owned());
    write_with_hash(
        &bootpart,
        &config_path.join("rugpi/primary.grubenv"),
        "/rugpi/primary.grubenv",
    )?;
    write_with_hash(
        &bootpart,
        &config_path.join("rugpi/secondary.grubenv"),
        "/rugpi/secondary.grubenv",
    )?;
    let mut boot_spare = HashMap::new();
    boot_spare.insert(RUGPI_BOOT_SPARE.to_owned(), "false".to_owned());
    std::fs::write(
        config_path.join("rugpi/boot_spare.grubenv"),
        grub_envblk_encode(&boot_spare)?,
    )?;
    Ok(())
}

pub fn commit(hot_partitions: PartitionSet) -> Anyhow<()> {
    let mut envblk = HashMap::new();
    match hot_partitions {
        PartitionSet::A => envblk.insert(RUGPI_BOOTPART.to_owned(), "2".to_owned()),
        PartitionSet::B => envblk.insert(RUGPI_BOOTPART.to_owned(), "3".to_owned()),
    };
    let _writable_config = make_config_writeable()?;
    write_with_hash(
        &envblk,
        &config_partition_path("rugpi/secondary.grubenv"),
        "/rugpi/secondary.grubenv",
    )?;
    write_with_hash(
        &envblk,
        &config_partition_path("rugpi/primary.grubenv"),
        "/rugpi/primary.grubenv",
    )?;
    Ok(())
}

pub fn set_spare_flag() -> Anyhow<()> {
    let mut envblk = HashMap::new();
    envblk.insert(RUGPI_BOOT_SPARE.to_owned(), "true".to_owned());
    let _writable_config = make_config_writeable()?;
    // It is safe to directly write to the file here. If the file is corrupt,
    // the system will simply boot from the default partition set.
    std::fs::write(
        config_partition_path("rugpi/boot_spare.grubenv"),
        grub_envblk_encode(&envblk)?,
    )?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use crate::boot::grub::{grub_envblk_decode, grub_envblk_encode};

    #[test]
    pub fn test_empty() {
        const GRUBENV: &str = include_str!("../../assets/grub/grubenv");
        assert_eq!(GRUBENV, grub_envblk_encode(&HashMap::new()).unwrap());
    }

    #[test]
    pub fn test_roundtrip() {
        const GRUBENV: &str = include_str!("../../assets/grub/grubenv");
        assert_eq!(
            GRUBENV,
            grub_envblk_encode(&grub_envblk_decode(GRUBENV).unwrap()).unwrap()
        );
        const DEFAULT: &str = include_str!("../../assets/grub/default.env");
        assert_eq!(
            DEFAULT,
            grub_envblk_encode(&grub_envblk_decode(DEFAULT).unwrap()).unwrap()
        );
    }
}
