//! Utilities for the Grub boot flow.

use std::collections::HashMap;

use thiserror::Error;

/// Signature of Grub environment blocks.
const ENVBLK_SIGNATURE: &str = "# GRUB Environment Block\n";

/// Size of Grub environment blocks.
const ENVBLK_SIZE: usize = 1024;

/// Decode a Grub environment block.
pub fn grub_envblk_decode(blk: &str) -> Result<HashMap<String, String>, InvalidEnvblk> {
    if blk.as_bytes().len() != ENVBLK_SIZE {
        return Err(InvalidEnvblk::InvalidLength);
    }
    let mut values = HashMap::new();
    for line in blk.split('\n') {
        if line.starts_with('#') {
            // Skip any lines starting with `#`, including the signature.
            continue;
        }
        if let Some((name, value)) = line.split_once('=') {
            let mut unescaped = String::with_capacity(value.len());
            let mut chars = value.chars();
            while let Some(c) = chars.next() {
                if c == '\\' {
                    match chars.next() {
                        Some('\\') => unescaped.push('\\'),
                        Some('\n') => unescaped.push('\n'),
                        _ => return Err(InvalidEnvblk::InvalidEscaped),
                    }
                } else {
                    unescaped.push(c)
                }
            }
            values.insert(name.to_owned(), unescaped);
        } else {
            return Err(InvalidEnvblk::InvalidEntry);
        }
    }
    Ok(values)
}

/// Invalid environment block.
#[derive(Debug, Clone, Error)]
pub enum InvalidEnvblk {
    /// Block has an invalid length.
    #[error("environment block has an invalid length")]
    InvalidLength,
    /// Block has an invalid signature.
    #[error("environment block has an invalid signature")]
    InvalidSignature,
    /// Block has an invalid entry.
    #[error("environment block has an invalid entry")]
    InvalidEntry,
    /// Block has an improperly escaped value.
    #[error("environment block contains an improperly escaped value")]
    InvalidEscaped,
}

/// Encode a Grub environment block.
pub fn grub_envblk_encode(values: &HashMap<String, String>) -> Result<String, InvalidEnvblk> {
    let mut encoded = String::with_capacity(ENVBLK_SIZE);
    encoded.push_str(ENVBLK_SIGNATURE);
    encoded.push_str("# WARNING: Do not edit this file by tools other than grub-editenv!!!\n");
    for (name, value) in values {
        assert!(!name.contains('\n'));
        encoded.push_str(name);
        encoded.push('=');
        for c in value.chars() {
            match c {
                '\\' => encoded.push_str("\\\\"),
                '\n' => encoded.push_str("\\n"),
                _ => encoded.push(c),
            }
        }
        encoded.push('\n');
    }
    if encoded.as_bytes().len() > ENVBLK_SIZE {
        return Err(InvalidEnvblk::InvalidLength);
    }
    while encoded.as_bytes().len() < ENVBLK_SIZE {
        encoded.push('#');
    }
    Ok(encoded)
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use crate::boot::grub::{grub_envblk_decode, grub_envblk_encode};

    #[test]
    pub fn test_empty() {
        const GRUBENV: &str = include_str!("../../assets/grub/grubenv");
        assert_eq!(GRUBENV, grub_envblk_encode(&HashMap::new()).unwrap());
    }

    #[test]
    pub fn test_roundtrip() {
        const GRUBENV: &str = include_str!("../../assets/grub/grubenv");
        assert_eq!(
            GRUBENV,
            grub_envblk_encode(&grub_envblk_decode(GRUBENV).unwrap()).unwrap()
        );
        const DEFAULT: &str = include_str!("../../assets/grub/default.env");
        assert_eq!(
            DEFAULT,
            grub_envblk_encode(&grub_envblk_decode(DEFAULT).unwrap()).unwrap()
        );
    }
}
