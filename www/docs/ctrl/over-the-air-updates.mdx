---
sidebar_position: 1
---

# Over-the-Air Updates

Rugix Ctrl's core functionality is the safe installation of _over-the-air_ (OTA) system updates.

**A/B Update Scheme.** A typical Rugix Ctrl setup uses an _A/B update scheme_ with redundant system partitions (A and B).
When an update is available, it is installed on the inactive partition (e.g., if the device is currently using partition A, the update is installed on partition B).
This allows the device to temporarily switch to the updated partition upon reboot, ensuring a seamless and fail-safe update process as the previous partition remains untouched and can be reverted to in case of any issues.
After on-device validation of the update, the update is then committed by permanently switching to the now active partition as the default boot partition.
This approach drastically reduces the likelihood of bricking devices in the field due to corrupted or incompatible software and failed or incomplete updates, thereby avoiding any related repair and maintenance costs.
In addition, it has the following advantages:

- OTA updates can almost completely run in the background, without adversely affecting any users of a device.
The only service interruption is caused, when the device reboots into the new version.
Rebooting to finalize an update can happen at the discretion of users and, if all goes well, does not take longer than any normal reboot, minimizing any inconveniences.
- As the previous version is kept, a rollback to the old version is possible if users experience any problems with the new version.[^rollback]

[^rollback]: This requires suppert by your application.

**Other Update Schemes.** We generally recommend using an A/B update scheme due to the advantages stated above.
For cases where an A/B update scheme is not the right choice, Rugix Ctrl can flexibly be configured for other update schemes, for instance, an asymmetric setup with a recovery partition or a setup with more than two redundant system partitions.
To configure Rugix Ctrl for such custom use cases, please have a look at the [System Configuration](./advanced/system-configuration.mdx) section of this documentation.

**Bootloader Integration.** To commit and switch between systems, Rugix Ctrl needs to integrate with the bootloader of the system.
Rugix Ctrl offers ready-made integrations with popular bootloaders.
Currently, it provides integrations for:

- [Raspberry Pi's `tryboot` Mechanism](https://www.raspberrypi.com/documentation/computers/config_txt.html#example-update-flow-for-ab-booting)
- [U-Boot](https://docs.u-boot.org/en/latest/) (popular on single board computers, GPL-2.0)
- [Grub](https://www.gnu.org/software/grub/) (well-established standard option, GPL-3.0)

:::tip
When building a system with Rugix Bakery for a generic or specific target, you will get a system with a bootloader integration for A/B OTA updates out-of-the-box. In that case, no further configuration is necessary and you do not have to worry about how the bootloader integration works.
If you want your own integration, check out the [documentation on boot flows](./advanced/boot-flows.md).
:::

**Typical Partition Layout.** A typical partition layout of a Rugix system following the A/B update scheme comprises six partitions:

- Partition 1: Contains the bootloader configuration for switching between the A and B system.
- Partition 2: Contains boot data, such as the Linux kernel, for the A system.
- Partition 3: Contains boot data, such as the Linux kernel, for the B system.
- Partition 4: Contains the root filesystem of the A system.
- Partition 5: Contains the root filesystem of the B system.
- Partition 6: Contains any persistent data and state (see [State Management](./state-management)).

We also refer to Partition 1 as the _config partition_ and to Partition 6 as the _data partition_.


## Updating a System

To update a system, you first need to build a system image, e.g., using Rugix Bakery, or a Rugix Ctrl update bundle.
Further, the image or bundle need to find their way onto the system that you want to update.
As explained earlier, how exactly this happens is up to you as Rugix Ctrl does not prescribe any delivery mechanism.
Once the image or bundle is on the device, you can install it with:

```shell
rugpi-ctrl update install <path to the image or bundle>
```

This command will also automatically try rebooting into the new version after it has been installed.
To prevent this from happening, use the `--no-reboot` command line flag.
Note that this command will not make the update permanent in any way.

When using the `--no-reboot` flag, a reboot to the inactive, _spare_ system[^spare-system] can later be triggered with:

[^spare-system]: This is the inactive system (A or B) to which we install updates.

```shell
rugpi-ctrl system reboot --spare
```

Rugix Ctrl also has support for _streaming updates_, i.e., installing updates without intermediately storing them on the device.
A streaming update will typically be directly written to the underlying storage while it is downloaded from the network.
You can use `-` as the input path to install an image streamed via stdin to Rugix Ctrl.
For instance, to download and install an image on-the-fly run:

```shell
curl <url to the image> | rugpi-ctrl update install -
```

Rugix Ctrl will also transparently decompress `xz` compressed images and update bundles provided to it via stdin. For other compression formats, you can pipe the image or bundle through the respective decompression tool before feeding it into Rugix Ctrl.

In case the internet connection of the device is unstable, you may also want to continue downloading and installing the update in the presence of intermittent network failures.
This can be achieved by running:

```shell
wget -q -t 0 -O - <url to the image> | rugpi-ctrl update install -
```

This will retry downloading indefinitely. For further details, we refer to the manpage of `wget`.

:::info
We highly recommend that you stream updates to devices.
This is not only faster, since the update has to be written to storage only once, but also has the advantage that it does not take up precious space on the data partition during the installation.
If your device is running low on space on the data partition, non-streaming updates may become impossible.
:::

### Committing an Update

Recall that Rugix Ctrl implements a two-stage update process where updates need to be committed to be permanent.
After rebooting into the new version and validating that everything is in working order, the update is made permanent with:

```shell
rugpi-ctrl system commit
```

Note that this command always makes the currently booted system the default system.
Hence, it must be run from within the updated version.
To prevent breaking the system, it is impossible to make the inactive system the default.[^inactive-default]

[^inactive-default]: At least with the `rugpi-ctrl` command line tool.

When to commit an update is up to the concrete update workflow of your application.
If you want to automatically commit the currently booted system during the boot process and are using Rugix Bakery, you can enable the recipe `core/rugpi-auto-commit`.
This recipe will install a system service that commits the currently booted system whenever it runs.
Note that this also means that it will commit an old version if booted into, for instance, when performing a rollback (see below).

:::tip
Use a [_pre-commit hook_](./hooks.md#system-update-hooks) to ensure that a commit is only possible when the system is in proper working order.
:::

### Performing a Rollback

Like updating, performing a rollback is a two-stage process.
A full rollback consists of first rebooting into the spare system (containing the previous version) and then committing the rollback after verifying that it is in proper working order.

To boot into the spare system, run:

```shell
rugpi-ctrl system reboot --spare
```

Then, after rebooting, commit the rollback with:

```shell
rugpi-ctrl system commit
```
